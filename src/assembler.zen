usingnamespace @import("const.zen");
const Opcode = @import("instruction.zen").Opcode;
const Reg = @import("cpu.zen").Reg;

pub const Assembler = struct {
    const Self = @This();

    pub fn init() Self {
        return Self{};
    }

    pub fn assemble(program: []REG_TYPE) [MEM_SIZE]u8 {
        var rom = [_]u8{0} ** MEM_SIZE;
        var i: usize = 0;
        for (program) |code| {
            // little endian
            rom[i] = @truncate(u8, code>>24);
            rom[i+1] = @truncate(u8, code>>16);
            rom[i+2] = @truncate(u8, code>>8);
            rom[i+3] = @truncate(u8, code);
            i += 4;
        }
        return rom;
    }
};

fn asmIType(opcode: u7, rd: Reg, funct3: REG_TYPE, rs1: Reg, imm: REG_TYPE) REG_TYPE {
    const rd_i = regToUint(rd);
    const rs1_i = regToUint(rs1);
    return (imm << 20) | (rs1_i << 15) | (funct3 << 12) | (rd_i << 7) | opcode;
}

// addi rd, rs1, imm
pub fn asmAddi(rd: Reg, rs1: Reg, imm: REG_TYPE) REG_TYPE {
    const opcode: u7 = @enumToInt(Opcode.Addi);
    const funct3: REG_TYPE = 0;
    return asmIType(opcode, rd, funct3, rs1, imm);
}

// ret
pub fn asmRet() REG_TYPE {
    return asmJalr(Reg.Zero, 0, Reg.Ra);
}

// jalr rd, offset(rs1)
pub fn asmJalr(rd: Reg, offset: REG_TYPE, rs1: Reg) REG_TYPE {
    const opcode: u7 = @enumToInt(Opcode.Jalr);
    const funct3: REG_TYPE = 0;
    return asmIType(opcode, rd, funct3, rs1, offset);
}

fn regToUint(r: Reg) REG_TYPE {
    return @enumToInt(r);
}