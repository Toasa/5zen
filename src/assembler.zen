usingnamespace @import("const.zen");
const Opcode = @import("instruction.zen").Opcode;
const Reg = @import("cpu.zen").Reg;

pub const Assembler = struct {
    const Self = @This();

    pub fn init() Self {
        return Self{};
    }

    pub fn assemble(program: []REG_TYPE) [MEM_SIZE]u8 {
        var rom = [_]u8{0} ** MEM_SIZE;
        var i: usize = 0;
        for (program) |code| {
            // little endian
            rom[i] = @truncate(u8, code>>24);
            rom[i+1] = @truncate(u8, code>>16);
            rom[i+2] = @truncate(u8, code>>8);
            rom[i+3] = @truncate(u8, code);
            i += 4;
        }
        return rom;
    }
};

// addi rd, rs1, imm
pub fn asm_addi(rd: Reg, rs1: Reg, imm: REG_TYPE) REG_TYPE {
    const rd_i = regToInt(rd);
    const rs1_i = regToInt(rs1);
    const opcode: u7 = @enumToInt(Opcode.Addi);
    return (imm << 20) | (rs1_i << 15) | (rd_i << 7) | opcode;
}

// ret
pub fn asm_ret() REG_TYPE {
    return asm_jalr(Reg.Zero, 0, Reg.Ra);
}

// jalr rd, offset(rs1)
pub fn asm_jalr(rd: Reg, offset: REG_TYPE, rs1: Reg) REG_TYPE {
    const rd_i = regToInt(rd);
    const rs1_i = regToInt(rs1);
    const opcode: u7 = 0b1100111;
    return (offset << 20) | (rs1_i << 15) | (rd_i << 7) | opcode;
}

fn regToInt(r: Reg) REG_TYPE {
    return @enumToInt(r);
}