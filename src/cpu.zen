usingnamespace @import("const.zen");
const std = @import("std");
const instruction = @import("instruction.zen");
const Inst = instruction.Inst;
const Opcode = instruction.Opcode;
const InstTypeSet = instruction.InstTypeSet;

pub const CPU = struct {
    const Self = @This();
    regs: [REG_NUM]REG_TYPE,
    pc: REG_TYPE,
    ram: [MEM_SIZE]u8,
    rom: [MEM_SIZE]u8,

    pub fn init(rom: [MEM_SIZE] u8) Self {
        var regs = [_]REG_TYPE{0} ** REG_NUM;
        regs[1] = RET_ADDR;
        return Self {
            .regs = regs,
            .pc = 0,
            .ram = [_]u8{0} ** MEM_SIZE,
            .rom = rom,
        };
    }

    pub fn fetch(self: *Self) REG_TYPE {
        // little endian
        const inst_byte0 = @is(REG_TYPE, self.rom[self.pc]) << 24;
        const inst_byte1 = @is(REG_TYPE, self.rom[self.pc+1]) << 16;
        const inst_byte2 = @is(REG_TYPE, self.rom[self.pc+2]) << 8;
        const inst_byte3 = @is(REG_TYPE, self.rom[self.pc+3]);
        const inst_bytes = inst_byte0 | inst_byte1 | inst_byte2 | inst_byte3;
        self.pc += 4;
        return inst_bytes;
    }

    pub fn decode(self: *Self, inst_bytes: REG_TYPE) Inst {
        // only RV32I
        const opcode_int = @truncate(u7, inst_bytes);
        const opcode = @intToEnum(Opcode, opcode_int);
        switch (opcode) {
            .Addi, .Jalr => {
                const I = decodeIType(inst_bytes);
                return Inst.init(opcode, I);
            },
            else => @panic("unknown opcode"),
        }
    }

    fn decodeIType(inst_bytes: REG_TYPE) InstTypeSet {
        const rs1 = @truncate(u5, inst_bytes >> 15);
        const rd = @truncate(u5, inst_bytes >> 7);
        const imm = @truncate(u12, inst_bytes >> 20);
        const func3 = @truncate(u3, inst_bytes >> 12);
        
        const itype = InstTypeSet.IType.init(rs1, rd, imm, func3);
        return InstTypeSet{ .I = itype };
    }

    pub fn execute(self: *Self, inst: Inst) void {
        const opcode = inst.opcode;
        switch(opcode) {
            .Addi => {
                const rd = inst.T.I.rd;
                const rs1 = inst.T.I.rs1;
                const imm = inst.T.I.imm;
                self.regs[rd] = self.regs[rs1] + imm;
            },
            .Jalr => {
                const rd = inst.T.I.rd;
                self.regs[rd] = self.pc + 4;
                const rs1 = inst.T.I.rs1;
                self.pc = self.regs[rs1];
            }
        }
    }

    // for debug
    pub fn printRegs(self: Self) void {
        var i: u32 = 0;
        for (self.regs) |reg| {
            std.debug.warn("reg{:2}: {}\n", i, reg);
            i += 1;
        }
    }
};

test "single addi" {
    const assembler = @import("assembler.zen");
    const Assembler = assembler.Assembler;
    const asm_addi = assembler.asm_addi;
    const asm_ret = assembler.asm_ret;
    const Emulator = @import("emulator.zen").Emulator;
    
    const program = &[_]REG_TYPE{
        // addi x5, x5, 8
        asm_addi(5, 5, 8),
        // ret
        asm_ret(),
    };

    const rom = Assembler.assemble(program);
    var emu = Emulator.init(rom);
    emu.run();

    std.testing.ok(emu.cpu.regs[5] == 8);
}

test "multi addi" {
    const assembler = @import("assembler.zen");
    const Assembler = assembler.Assembler;
    const asm_addi = assembler.asm_addi;
    const asm_ret = assembler.asm_ret;
    const Emulator = @import("emulator.zen").Emulator;

    const program = &[_]REG_TYPE{
        // addi x6, x6, 1
        asm_addi(6, 6, 1),
        // addi x3, x2, 1023
        asm_addi(7, 6, 1023),
        // ret
        asm_ret(),
    };

    const rom = Assembler.assemble(program);
    var emu = Emulator.init(rom);
    emu.run();

    std.testing.ok(emu.cpu.regs[7] == 1024);
}