usingnamespace @import("const.zen");
const std = @import("std");
const instruction = @import("instruction.zen");
const Inst = instruction.Inst;
const Opcode = instruction.Opcode;
const InstTypeSet = instruction.InstTypeSet;

pub const CPU = struct {
    const Self = @This();
    regs: [REG_NUM]REG_TYPE,
    pc: REG_TYPE,
    ram: [MEM_SIZE]u8,
    rom: [MEM_SIZE]u8,

    pub fn init(rom: [MEM_SIZE] u8) Self {
        var regs = [_]REG_TYPE{0} ** REG_NUM;
        regs[1] = RET_ADDR;
        return Self {
            .regs = regs,
            .pc = 0,
            .ram = [_]u8{0} ** MEM_SIZE,
            .rom = rom,
        };
    }

    pub fn fetch(self: *Self) REG_TYPE {
        // little endian
        const inst_byte0 = @is(REG_TYPE, self.rom[self.pc]) << 24;
        const inst_byte1 = @is(REG_TYPE, self.rom[self.pc+1]) << 16;
        const inst_byte2 = @is(REG_TYPE, self.rom[self.pc+2]) << 8;
        const inst_byte3 = @is(REG_TYPE, self.rom[self.pc+3]);
        const inst_bytes = inst_byte0 | inst_byte1 | inst_byte2 | inst_byte3;
        self.pc += 4;
        return inst_bytes;
    }

    pub fn decode(self: *Self, inst_bytes: REG_TYPE) Inst {
        // only RV32I
        const opcode_int = @truncate(u7, inst_bytes);
        const opcode = @intToEnum(Opcode, opcode_int);
        switch (opcode) {
            .Addi, .Jalr => {
                const I = decodeIType(inst_bytes);
                return Inst.init(opcode, I);
            },
            else => @panic("unknown opcode"),
        }
    }

    fn decodeIType(inst_bytes: REG_TYPE) InstTypeSet {
        const rs1 = @truncate(u5, inst_bytes >> 15);
        const rd = @truncate(u5, inst_bytes >> 7);
        const imm = @truncate(u12, inst_bytes >> 20);
        const func3 = @truncate(u3, inst_bytes >> 12);
        
        const itype = InstTypeSet.IType.init(rs1, rd, imm, func3);
        return InstTypeSet{ .I = itype };
    }

    pub fn execute(self: *Self, inst: Inst) void {
        const opcode = inst.opcode;
        switch(opcode) {
            .Addi => {
                const rd = inst.T.I.rd;
                const rs1 = inst.T.I.rs1;
                const imm = inst.T.I.imm;
                const data = self.regRead(rs1) + imm;
                self.regWrite(rd, data);
            },
            .Jalr => {
                const rd = inst.T.I.rd;
                self.regWrite(rd, self.pc + 4);
                const rs1 = inst.T.I.rs1;
                self.pc = self.regs[rs1];
            }
        }
    }

    fn regRead(self: Self, reg: u5) REG_TYPE {
        // zero register's value is always zero.
        if (reg == 0) {
            return 0;
        }
        return self.regs[reg];
    }

    fn regWrite(self: *Self, reg: u5, data: REG_TYPE) void {
        self.regs[reg] = data;
    }

    // for debug
    pub fn printRegs(self: Self) void {
        var i: u32 = 0;
        for (self.regs) |reg| {
            std.debug.warn("reg{:2}: {}\n", i, reg);
            i += 1;
        }
    }
};

// Register
pub const Reg = enum {
    Zero, // constant zero
    Ra,   // return address
    Sp,   // stack pointer
    Gp,   // global pointer
    Tp,   // thread pointer
    T0,   // tmp0
    T1,   // tmp1
    T2,   // tmp2
    S0,   // save0
    S1,   // save1
    A0,   // function argument or frame pointer
    A1,   // function argument
    A2,   // function argument
    A3,   // function argument
    A4,   // function argument
    A5,   // function argument
    A6,   // function argument
    A7,   // function argument
    S2,   // save2
    S3,   // save3
    S4,   // save4
    S5,   // save5
    S6,   // save6
    S7,   // save7
    S8,   // save8
    S9,   // save9
    S10,  // save10
    S11,  // save11
    T3,   // tmp3
    T4,   // tmp4
    T5,   // tmp5
    T6,   // tmp6
};

test "single addi" {
    const assembler = @import("assembler.zen");
    const Assembler = assembler.Assembler;
    const asm_addi = assembler.asm_addi;
    const asm_ret = assembler.asm_ret;
    const Emulator = @import("emulator.zen").Emulator;
    
    const program = &[_]REG_TYPE{
        asm_addi(Reg.T0, Reg.T0, 8),
        asm_ret(),
    };

    const rom = Assembler.assemble(program);
    var emu = Emulator.init(rom);
    emu.run();

    const t0 = @enumToInt(Reg.T0);
    std.testing.ok(emu.cpu.regRead(t0) == 8);
}

test "multi addi" {
    const assembler = @import("assembler.zen");
    const Assembler = assembler.Assembler;
    const asm_addi = assembler.asm_addi;
    const asm_ret = assembler.asm_ret;
    const Emulator = @import("emulator.zen").Emulator;

    const program = &[_]REG_TYPE{
        asm_addi(Reg.T1, Reg.T1, 1),
        asm_addi(Reg.T2, Reg.T1, 1023),
        asm_ret(),
    };

    const rom = Assembler.assemble(program);
    var emu = Emulator.init(rom);
    emu.run();

    const t2 = @enumToInt(Reg.T2);
    std.testing.ok(emu.cpu.regRead(t2) == 1024);
}