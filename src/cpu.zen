usingnamespace @import("const.zen");
const std = @import("std");
const instruction = @import("instruction.zen");
const InstructionSet = instruction.InstructionSet;
const AddInst = InstructionSet.AddInst;
const AddiInst = InstructionSet.AddiInst;
const JalInst = InstructionSet.JalInst;
const JalrInst = InstructionSet.JalrInst;
const Operand = instruction.Operand;

pub const CPU = struct {
    const Self = @This();
    regs: [REG_NUM]REG_TYPE,
    pc: REG_TYPE,
    ram: [MEM_SIZE]u8,
    rom: [MEM_SIZE]u8,

    pub fn init(rom: [MEM_SIZE] u8) Self {
        var regs = [_]REG_TYPE{0} ** REG_NUM;
        regs[1] = RET_ADDR;
        return Self {
            .regs = regs,
            .pc = 0,
            .ram = [_]u8{0} ** MEM_SIZE,
            .rom = rom,
        };
    }

    pub fn fetch(self: *Self) REG_TYPE {
        // little endian
        const inst_byte0 = @is(REG_TYPE, self.rom[self.pc]) << 24;
        const inst_byte1 = @is(REG_TYPE, self.rom[self.pc+1]) << 16;
        const inst_byte2 = @is(REG_TYPE, self.rom[self.pc+2]) << 8;
        const inst_byte3 = @is(REG_TYPE, self.rom[self.pc+3]);
        const inst_bytes = inst_byte0 | inst_byte1 | inst_byte2 | inst_byte3;
        return inst_bytes;
    }

    pub fn decode(self: *Self, inst_bytes: REG_TYPE) InstructionSet {
        // only RV32I
        const opcode = @truncate(u7, inst_bytes);

        // each instruction is NOT determined by `opcode`.
        switch (opcode) {
            AddInst.opcode => {
                const operand = decodeRType(inst_bytes);
                return InstructionSet.createAdd(operand);
            },
            AddiInst.opcode => {
                const operand = decodeIType(inst_bytes);
                return InstructionSet.createAddi(operand);
            },
            JalInst.opcode => {
                const operand = decodeJType(inst_bytes);
                return InstructionSet.createJal(operand);
            },
            JalrInst.opcode => {
                const operand = decodeIType(inst_bytes);
                return InstructionSet.createJalr(operand);
            },
            else => @panic("unknown opcode"),
        }
    }

    fn decodeRType(inst_bytes: REG_TYPE) Operand {
        const rs1 = @truncate(u5, inst_bytes >> 15);
        const rs2 = @truncate(u5, inst_bytes >> 20);
        const rd = @truncate(u5, inst_bytes >> 7);
        const func3 = @truncate(u3, inst_bytes >> 12);
        const func7 = @truncate(u7, inst_bytes >> 25);
        
        const rtype = Operand.RType.init(rs1, rs2, rd, func3, func7);
        return Operand{ .R = rtype };
    }

    fn decodeIType(inst_bytes: REG_TYPE) Operand {
        const rs1 = @truncate(u5, inst_bytes >> 15);
        const rd = @truncate(u5, inst_bytes >> 7);
        const imm = @truncate(u12, inst_bytes >> 20);
        const func3 = @truncate(u3, inst_bytes >> 12);
        
        const itype = Operand.IType.init(rs1, rd, imm, func3);
        return Operand{ .I = itype };
    }

    fn decodeJType(inst_bytes: REG_TYPE) Operand {
        const rd = @truncate(u5, inst_bytes >> 7);
        const imm10_1 = @truncate(u9, inst_bytes >> 22);
        const imm11 = @truncate(u1, inst_bytes >> 20);
        const imm12_19 = @truncate(u8, inst_bytes >> 12);
        const imm20 = @truncate(u1, inst_bytes >> 31);

        const imm10_1_ = @intCast(u20, imm10_1);
        const imm11_ = @intCast(u20, imm11);
        const imm12_19_ = @intCast(u20, imm12_19);
        const imm20_ = @intCast(u20, imm20);

        const imm_u = (imm20_ << 19) | (imm12_19_ << 11) | (imm11_ << 10) | imm10_1_;

        const imm = @bitCast(i20, imm_u);
        const jtype = Operand.JType.init(rd, imm);
        return Operand{ .J = jtype };
    }

    pub fn execute(self: *Self, inst: InstructionSet) void {
        switch(inst) {
            .Add => |add| {
                const rs1 = add.operand.R.rs1;
                const rs2 = add.operand.R.rs2;
                const rd = add.operand.R.rd;
                const data = self.regRead(rs1) + self.regRead(rs2);
                self.regWrite(rd, data);
                self.pc += 4;
            },
            .Addi => |addi| {
                const rd = addi.operand.I.rd;
                const rs1 = addi.operand.I.rs1;
                const imm = addi.operand.I.imm;
                const data = self.regRead(rs1) + imm;
                self.regWrite(rd, data);
                self.pc += 4;
            },
            .Jal => |jal| {
                const rd = jal.operand.J.rd;
                const imm = jal.operand.J.imm;
                self.regWrite(rd, self.pc + 4);
                var pc_i = @bitCast(i32, self.pc);
                pc_i += imm;
                self.pc = @bitCast(REG_TYPE, pc_i);
            },
            .Jalr => |jalr| {
                const rd = jalr.operand.I.rd;
                self.regWrite(rd, self.pc + 4);
                const rs1 = jalr.operand.I.rs1;
                self.pc = self.regs[rs1];
            }
        }
    }

    fn regRead(self: Self, reg: u5) REG_TYPE {
        // zero register's value is always zero.
        if (reg == 0) {
            return 0;
        }
        return self.regs[reg];
    }

    fn regWrite(self: *Self, reg: u5, data: REG_TYPE) void {
        self.regs[reg] = data;
    }

    // for debug
    pub fn printRegs(self: Self) void {
        var i: @TagType(Reg) = 0;
        for (self.regs) |reg_val| {
            const reg = @intToEnum(Reg, i);
            const reg_name = @tagName(reg);
            std.debug.warn("{}: {}\n", reg_name, reg_val);
            i +%= 1;
        }
    }
};

// Register
pub const Reg = enum {
    Zero, // constant zero
    Ra,   // return address
    Sp,   // stack pointer
    Gp,   // global pointer
    Tp,   // thread pointer
    T0,   // tmp0
    T1,   // tmp1
    T2,   // tmp2
    S0,   // save0
    S1,   // save1
    A0,   // function argument or frame pointer
    A1,   // function argument
    A2,   // function argument
    A3,   // function argument
    A4,   // function argument
    A5,   // function argument
    A6,   // function argument
    A7,   // function argument
    S2,   // save2
    S3,   // save3
    S4,   // save4
    S5,   // save5
    S6,   // save6
    S7,   // save7
    S8,   // save8
    S9,   // save9
    S10,  // save10
    S11,  // save11
    T3,   // tmp3
    T4,   // tmp4
    T5,   // tmp5
    T6,   // tmp6
};

test "single addi instruction" {
    const assembler = @import("assembler.zen");
    const Assembler = assembler.Assembler;
    const asmAddi = assembler.asmAddi;
    const asmRet = assembler.asmRet;
    const Emulator = @import("emulator.zen").Emulator;
    
    const program = &[_]REG_TYPE{
        asmAddi(Reg.T0, Reg.T0, 8),
        asmRet(),
    };

    const rom = Assembler.assemble(program);
    var emu = Emulator.init(rom);
    emu.run();

    const t0 = @enumToInt(Reg.T0);
    std.testing.ok(emu.cpu.regRead(t0) == 8);
}

test "multi addi instruction" {
    const assembler = @import("assembler.zen");
    const Assembler = assembler.Assembler;
    const asmAddi = assembler.asmAddi;
    const asmRet = assembler.asmRet;
    const Emulator = @import("emulator.zen").Emulator;

    const program = &[_]REG_TYPE{
        asmAddi(Reg.T1, Reg.T1, 1),
        asmAddi(Reg.T2, Reg.T1, 1023),
        asmRet(),
    };

    const rom = Assembler.assemble(program);
    var emu = Emulator.init(rom);
    emu.run();

    const t2 = @enumToInt(Reg.T2);
    std.testing.ok(emu.cpu.regRead(t2) == 1024);
}

test "add instruction" {
    const assembler = @import("assembler.zen");
    const Assembler = assembler.Assembler;
    const asmAdd = assembler.asmAdd;
    const asmAddi = assembler.asmAddi;
    const asmRet = assembler.asmRet;
    const Emulator = @import("emulator.zen").Emulator;

    const program = &[_]REG_TYPE{
        asmAddi(Reg.T0, Reg.T0, 1),
        asmAddi(Reg.T1, Reg.T1, 1023),
        asmAdd(Reg.T2, Reg.T1, Reg.T0),
        asmRet(),
    };

    const rom = Assembler.assemble(program);
    var emu = Emulator.init(rom);
    emu.run();

    const t2 = @enumToInt(Reg.T2);
    std.testing.ok(emu.cpu.regRead(t2) == 1024);
}

test "jal instruction" {
    const assembler = @import("assembler.zen");
    const Assembler = assembler.Assembler;
    const asmAddi = assembler.asmAddi;
    const asmJal = assembler.asmJal;
    const asmRet = assembler.asmRet;
    const Emulator = @import("emulator.zen").Emulator;

    const program = &[_]REG_TYPE{
        asmAddi(Reg.T1, Reg.T1, 10),
        asmJal(Reg.Zero, 8),
        // jump this instruction
        asmAddi(Reg.T1, Reg.T1, 20),
        asmRet(),
    };

    const rom = Assembler.assemble(program);
    var emu = Emulator.init(rom);
    emu.run();

    const t1 = @enumToInt(Reg.T1);
    std.testing.ok(emu.cpu.regRead(t1) == 10);
}